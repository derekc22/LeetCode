class Solution(object):




    def findAllConcatenatedWordsInADict(self, words):
        """
        :type words: List[str]
        :rtype: List[str]
        """



# if __name__ == '__main__':

#     # def partitions(num):
#     #     nums = [i for i in range(1, num+1)]

def generate_partitions(n, max_part=None):
    """
    Generate all integer partitions of n (order of summands does not matter).
    Returns a list of partitions, each partition is represented as a list of integers in non-increasing order.
    """
    if max_part is None or max_part > n:
        max_part = n
    result = []

    def helper(remaining, max_part, current):
        if remaining == 0:
            # Found a valid partition; append a copy of current
            result.append(current.copy())
        else:
            # Try next part size from max_part down to 1
            for k in range(min(remaining, max_part), 0, -1):
                current.append(k)
                helper(remaining - k, k, current)
                current.pop()

    helper(n, max_part, [])
    return result

if __name__ == "__main__":
    n = 8
    partitions = generate_partitions(n)
    print(f"All partitions of {n} ({len(partitions)} total):")
    for part in partitions:
        print("+".join(map(str, part)))

        

